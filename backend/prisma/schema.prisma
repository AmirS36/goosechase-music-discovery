// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

model User {
  id       Int    @id @default(autoincrement())
  username String @unique
  password String

  preference   Preference? @relation(fields: [preferenceId], references: [id])
  preferenceId Int?        @unique

  createdAt DateTime @default(now())
  updatedAt DateTime @default(now())

  // Spotify Fields
  spotifyId             String? @unique
  spotifyDisplayName    String?
  spotifyImageUrl       String?
  spotifyAccessToken    String?
  spotifyRefreshToken   String?
  spotifyTokenExpiresAt Int?

  swipes Swipe[]

  lyricalFeatures  LyricalFeature[] // backref for LyricalFeature.user
  tasteProgress    TasteProgress? // backref for TasteProgress.user (1:1)
  userLyricalTaste UserLyricalTaste? // backref for UserLyricalTas
}

model Preference {
  id            Int     @id @default(autoincrement())
  likesHipHop   Float   @default(0)
  likesPop      Float   @default(0)
  prefersHappy  Float   @default(0)
  avgBPM        Float   @default(0)
  allowExplicit Boolean @default(false)

  user User? @relation
}

enum SwipeDirection {
  LEFT
  RIGHT
}

model Track {
  /// Spotify track ID (22 chars). Using String keeps it DB-agnostic.
  id              String           @id
  title           String
  artist          String
  imageUrl        String?
  previewUrl      String?
  spotifyUrl      String           @unique
  swipes          Swipe[]
  lyricalFeatures LyricalFeature[] // backref for LyricalFeature.track
}

model Swipe {
  id        Int            @id @default(autoincrement())
  userId    Int
  trackId   String
  direction SwipeDirection
  createdAt DateTime       @default(now())
  sessionId String? // optional: to group your 5-card batches
  rank      Int? // optional: index of the card in the batch

  user  User  @relation(fields: [userId], references: [id])
  track Track @relation(fields: [trackId], references: [id])
  // If you want 1 row per (user,track) instead of a history, uncomment:
  // @@unique([userId, trackId])

  @@index([userId, createdAt])
  @@index([trackId, createdAt])
}

model LyricalFeature {
  id               Int     @id @default(autoincrement())
  userId           Int
  trackId          String // Spotify Track.id
  // ----- extracted fields (as you requested) -----
  lyricalThemes    String? // JSON string of string[] (e.g. ["love","nostalgia"])
  lyricalMood      String? // e.g. "happy" | "sad" | ...
  lyricalStyle     String? // e.g. "simple" | "metaphorical"
  lyricalGrand     String? // e.g. "Simple", "Elevated"
  lyricalGrandPres Int? // percentage of elevated words
  lyricalLang      String? // e.g. "en" | "he"

  createdAt DateTime @default(now())

  user  User  @relation(fields: [userId], references: [id])
  track Track @relation(fields: [trackId], references: [id])

  @@unique([userId, trackId]) // one feature row per (user,track)
  @@index([userId, createdAt])
  @@index([trackId])
}

/// A rolling “cursor” so we know what swipes were processed already
model TasteProgress {
  userId               Int       @id
  lastProcessedSwipeId Int? // last Swipe.id included in the rollup
  lastProcessedAt      DateTime?

  user User @relation(fields: [userId], references: [id])
}

/// Aggregated, per-user lyrical taste snapshot (latest rollup)
model UserLyricalTaste {
  id            Int      @id @default(autoincrement())
  userId        Int      @unique
  // Canonical rollup (store as strings for simplicity / add-only)
  topThemesJSON String? // JSON string of top themes ["love","nostalgia",...]
  dominantMood  String? // e.g. "melancholic"
  dominantStyle String? // e.g. "metaphorical"
  grandStyle    String? // e.g. "Elevated"
  grandStyleAvg Int? // avg elevated% across liked tracks
  langPrefsJSON String? // JSON like [{"lang":"en","share":0.8},{"lang":"he","share":0.2}]
  sampleSize    Int      @default(0)
  updatedAt     DateTime @default(now())
  // The natural-language assessment generated by ChatGPT
  assessment    String?

  user User @relation(fields: [userId], references: [id])
}

//to avoid analyzing the same track twice
model LyricAnalysisCache {
  id        Int      @id @default(autoincrement())
  trackId   Int?     @unique        // if you have it
  title     String
  artist    String
  snippet   String?  // optional – affects the hash
  result    Json
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([title, artist])
}
